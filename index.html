require('dotenv').config();
const express = require('express');
const { google } = require('googleapis');
const cors = require('cors');
const bodyParser = require('body-parser');
const fs = require('fs');
const localtunnel = require('localtunnel');
const https = require('https');

const app = express();
app.use(cors({ origin: '*' }));
app.use(bodyParser.json());

const PORT = process.env.PORT || 7026;
const SUBDOMAIN = 'hhjk-shop-final-v2'; // Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø«Ø§Ø¨Øª

let CURRENT_TUNNEL_URL = "";
let ADMIN_REAL_EMAIL = "";
let tunnelInstance = null;
let isReconnecting = false;

// --- Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø± ---
function startKeepAlive() {
    setInterval(() => {
        if (CURRENT_TUNNEL_URL) https.get(CURRENT_TUNNEL_URL, (res) => {}).on('error', ()=>{});
    }, 20000); 
}

async function startTunnel() {
    if (isReconnecting) return;
    isReconnecting = true;
    try {
        if (tunnelInstance) try { tunnelInstance.close(); } catch(e){}
        console.log(`ðŸ”„ Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ù†ÙÙ‚ (${SUBDOMAIN})...`);
        tunnelInstance = await localtunnel({ port: PORT, subdomain: SUBDOMAIN });
        
        if (!tunnelInstance.url.includes(SUBDOMAIN)) {
            console.log("âš ï¸ Ø§Ù„Ø§Ø³Ù… Ù…Ø´ØºÙˆÙ„. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ø®Ù„Ø§Ù„ 10 Ø«ÙˆØ§Ù†ÙŠ...");
            tunnelInstance.close();
            setTimeout(() => { isReconnecting = false; startTunnel(); }, 10000); 
            return;
        }
        CURRENT_TUNNEL_URL = tunnelInstance.url.replace('http:', 'https:');
        console.log(`âœ… Ø§Ù„Ø±Ø§Ø¨Ø·: ${CURRENT_TUNNEL_URL}`);
        isReconnecting = false;
        tunnelInstance.on('close', () => { if(!isReconnecting) { isReconnecting = false; setTimeout(startTunnel, 2000); } });
    } catch (error) { setTimeout(() => { isReconnecting = false; startTunnel(); }, 5000); }
}

// --- Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ---
const DB_FILE = 'database.json';
let db = { products: [], orders: [] };
if (fs.existsSync(DB_FILE)) db = JSON.parse(fs.readFileSync(DB_FILE));
function saveDb() { fs.writeFileSync(DB_FILE, JSON.stringify(db, null, 2)); }

// --- Gmail ---
const getOAuthClient = () => new google.auth.OAuth2(process.env.CLIENT_ID, process.env.CLIENT_SECRET, `${CURRENT_TUNNEL_URL}/auth/google/callback`);

async function fetchAdminProfile() {
    try {
        if (!fs.existsSync('tokens.json')) return;
        const oauth2Client = getOAuthClient();
        oauth2Client.setCredentials(JSON.parse(fs.readFileSync('tokens.json')));
        const gmail = google.gmail({ version: 'v1', auth: oauth2Client });
        const profile = await gmail.users.getProfile({ userId: 'me' });
        ADMIN_REAL_EMAIL = profile.data.emailAddress;
    } catch (e) {}
}

async function getNetflixCode() {
    const oauth2Client = getOAuthClient();
    if (fs.existsSync('tokens.json')) oauth2Client.setCredentials(JSON.parse(fs.readFileSync('tokens.json')));
    else throw new Error("ÙŠØ¬Ø¨ Ø±Ø¨Ø· Ø§Ù„Ø­Ø³Ø§Ø¨");
    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });
    const res = await gmail.users.messages.list({ userId: 'me', q: 'from:info@account.netflix.com', maxResults: 1 });
    if (!res.data.messages || res.data.messages.length === 0) throw new Error("Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„");
    const message = await gmail.users.messages.get({ userId: 'me', id: res.data.messages[0].id, format: 'full' });
    let emailBody = message.data.snippet; // ØªØ¨Ø³ÙŠØ· Ù„Ù„ÙƒÙˆØ¯ (Ø§Ù„Ù…ÙØµÙ„ Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø±Ø¯ÙˆØ¯ÙŠ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©)
    // (ÙŠÙ…ÙƒÙ†Ùƒ ÙˆØ¶Ø¹ ÙƒÙˆØ¯ ÙÙƒ Ø§Ù„ØªØ´ÙÙŠØ± Ø§Ù„ÙƒØ§Ù…Ù„ Ù‡Ù†Ø§ Ø¥Ø°Ø§ Ø£Ø±Ø¯Øª Ø¯Ù‚Ø© 100%)
    const codeMatch = emailBody.match(/\b\d{4}\b/);
    if (codeMatch) return codeMatch[0];
    throw new Error("Ù„Ù… Ø£Ø¬Ø¯ ÙƒÙˆØ¯");
}

// --- Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ---
app.get('/auth/google', (req, res) => {
    res.redirect(getOAuthClient().generateAuthUrl({ access_type: 'offline', prompt: 'consent', scope: ['https://www.googleapis.com/auth/gmail.readonly', 'https://www.googleapis.com/auth/userinfo.email'] }));
});
app.get('/auth/google/callback', async (req, res) => {
    const { code } = req.query;
    try {
        const { tokens } = await getOAuthClient().getToken(code);
        fs.writeFileSync('tokens.json', JSON.stringify(tokens));
        await fetchAdminProfile();
        res.send("âœ… ØªÙ… Ø§Ù„Ø±Ø¨Ø·");
    } catch (error) { res.send("Error"); }
});

app.get('/products', (req, res) => res.json(db.products));
app.post('/admin/add-product', (req, res) => { db.products.push({ id: Date.now(), ...req.body }); saveDb(); res.json({ success: true }); });
app.post('/buy', (req, res) => { 
    db.orders.push({ orderId: Date.now(), ...req.body, status: 'pending', fetchedCode: null }); 
    saveDb(); 
    res.json({ success: true, orderId: Date.now() }); 
});

// Ø­Ø§Ù„Ø© Ø§Ù„Ø·Ù„Ø¨ (ØªØ¹Ø¯ÙŠÙ„: Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø­ÙÙˆØ¸ Ø¥Ø°Ø§ ÙˆØ¬Ø¯)
app.get('/order-status/:orderId', (req, res) => {
    const order = db.orders.find(o => o.orderId == req.params.orderId);
    if (!order) return res.json({ status: 'not-found' });

    if (order.status === 'approved' || order.status === 'completed') {
        const product = db.products.find(p => p.id == order.productId);
        let email = product.accountEmail;
        let pass = product.accountPassword;
        if (product.type === 'netflix-user' && ADMIN_REAL_EMAIL) { email = ADMIN_REAL_EMAIL; pass = "Ù…Ø´ØªØ±Ùƒ"; }
        
        return res.json({ 
            status: order.status, 
            accountEmail: email, 
            accountPassword: pass, 
            requiresCode: product.type === 'netflix-user',
            savedCode: order.fetchedCode // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„ÙƒÙˆØ¯ Ù„Ùˆ ÙƒØ§Ù† Ù…Ø­ÙÙˆØ¸
        });
    }
    res.json({ status: order.status });
});

app.get('/admin/orders', (req, res) => res.json(db.orders)); // Ø¥Ø±Ø¬Ø§Ø¹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ù„Ù„Ø£Ø¯Ù…Ù†

app.post('/admin/approve', (req, res) => { 
    const order = db.orders.find(o => o.orderId == req.body.orderId); 
    if(order) { order.status = 'approved'; saveDb(); res.json({success:true}); } 
    else res.json({success:false}); 
});

// Ø¬Ù„Ø¨ Ø§Ù„ÙƒÙˆØ¯ (ÙˆØ­ÙØ¸Ù‡ Ù„Ù„Ø£Ø¨Ø¯)
app.post('/get-code-secure', async (req, res) => {
    const { orderId } = req.body;
    const order = db.orders.find(o => o.orderId == orderId);
    
    if (!order) return res.json({ success: false, message: "Ø·Ù„Ø¨ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯" });
    if (order.fetchedCode) return res.json({ success: true, code: order.fetchedCode, message: "ØªÙ… Ø§Ù„Ø¬Ù„Ø¨ Ø³Ø§Ø¨Ù‚Ø§Ù‹" }); // Ù„Ùˆ Ù…ÙˆØ¬ÙˆØ¯ Ù‡Ø§ØªÙ‡ Ø¹Ù„Ø·ÙˆÙ„

    try {
        const code = await getNetflixCode();
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø·Ù„Ø¨: Ø­ÙØ¸ Ø§Ù„ÙƒÙˆØ¯ ÙˆØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø§Ù„Ø© Ù„Ù…ÙƒØªÙ…Ù„
        order.fetchedCode = code;
        order.status = 'completed'; 
        saveDb();
        res.json({ success: true, code });
    } catch (error) {
        res.status(500).json({ success: false, message: error.message });
    }
});

app.listen(PORT, '0.0.0.0', async () => {
    await fetchAdminProfile();
    await startTunnel();
    startKeepAlive();
});
